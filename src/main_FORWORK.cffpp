#include <iostream>
#include "vendor/glad/include/glad/glad.h"
#include <GLFW/glfw3.h>
#include "../api/api.hpp"

const int width = 1280, height = 720;

float rectangleVert[] = {
    1, -1,  1, 0,
    -1, -1,  0, 0,
    -1, 1,  0, 1,

    1, 1,  1, 1,
    1, -1,  1, 0,
    -1, 1,  0, 1,
};

std::vector<HyperAPI::Vertex> vertices =
{ //     COORDINATES        /        COLORS         /    TexCoord       /       NORMALS      //
	{glm::vec3(-10, 0, 10), glm::vec3(0.3,0.3,0.3), glm::vec3(0,1,0), glm::vec2(0, 0)},
	{glm::vec3(-10, 0, -10), glm::vec3(0.3,0.3,0.3), glm::vec3(0,1,0), glm::vec2(0, 10)},
	{glm::vec3(10, 0, -10), glm::vec3(0.3,0.3,0.3), glm::vec3(0,1,0), glm::vec2(10, 10)},
	{glm::vec3(10, 0, 10), glm::vec3(0.3,0.3,0.3), glm::vec3(0,1,0), glm::vec2(10, 0)}
    
    // -10.0f, 0.0f,  10.0f,		0.0f, 0.0f, 0.0f,		0.0f,   0.0f,		0.0f, 1.0f, 0.0f,
	// -10.0f, 0.0f, -10.0f,		0.0f, 0.0f, 0.0f,		0.0f,  10.0f,		0.0f, 1.0f, 0.0f,
	//  10.0f, 0.0f, -10.0f,		0.0f, 0.0f, 0.0f,		10.0f, 10.0f,		0.0f, 1.0f, 0.0f,
	//  10.0f, 0.0f,  10.0f,		0.0f, 0.0f, 0.0f,		10.0f,  0.0f,		0.0f, 1.0f, 0.0f
};

std::vector<HyperAPI::Vertex> bgVerts = {
    { glm::vec3(-5, -5, 0), glm::vec3(1,1,1), glm::vec3(0, 1, 0), glm::vec2(0, 0) },
    { glm::vec3(-5, 5, 0), glm::vec3(1,1,1), glm::vec3(0, 1, 0), glm::vec2(0, 5) },
    { glm::vec3(5, 5, 0), glm::vec3(1,1,1), glm::vec3(0, 1, 0), glm::vec2(5, 5) },
    { glm::vec3(5, -5, 0), glm::vec3(1,1,1), glm::vec3(0, 1, 0), glm::vec2(5, 0) },
};

std::vector<unsigned int> bgIndices = {
    0, 1, 2,
    0, 2, 3
};

std::vector<HyperAPI::Vertex> spriteVerts2 = {
    { glm::vec3(-0.5, -0.5, 0), glm::vec3(1,1,1), glm::vec3(0, 1, 0), glm::vec2(0, 0) },
    { glm::vec3(-0.5, 0.5, 0), glm::vec3(1,1,1), glm::vec3(0, 1, 0), glm::vec2(0, 1) },
    { glm::vec3(0.5, 0.5, 0), glm::vec3(1,1,1), glm::vec3(0, 1, 0), glm::vec2(1, 1) },
    { glm::vec3(0.5, -0.5, 0), glm::vec3(1,1,1), glm::vec3(0, 1, 0), glm::vec2(1, 0) },
};

std::vector<unsigned int> spriteIndices2 = {
    0, 1, 2,
    0, 2, 3
};

// Indices for vertices order
std::vector<unsigned int> indices =
{
	0, 1, 2,
	0, 2, 3
};

void NewFrame(unsigned int FBO) {
    glBindFramebuffer(GL_FRAMEBUFFER, FBO);
    glClearColor(0.2f, 0.2f, 0.2f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
    glEnable(GL_DEPTH_TEST);

    glViewport(0, 0, width, height);
    glEnable(GL_DEPTH_TEST);
}

void EndFrame(HyperAPI::Shader &framebufferShader, unsigned int FBO, unsigned int rectVAO, unsigned int postProcessingTexture, unsigned int postProcessingFBO) {
    glBindFramebuffer(GL_READ_FRAMEBUFFER, FBO);
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, postProcessingFBO);
    glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);

    glBindFramebuffer(GL_FRAMEBUFFER, 0);

    framebufferShader.Bind();
    glBindVertexArray(rectVAO);
    glDisable(GL_DEPTH_TEST);
    glBindTexture(GL_TEXTURE_2D, postProcessingTexture);
    glDrawArrays(GL_TRIANGLES, 0, 6);

    glDepthFunc(GL_LEQUAL);
}

int main() {
    HyperAPI::Renderer renderer(width, height, "Hello World", {0, -0.2f});

    double prevTime = 0;
    double currTime = 0;
    double timeDiff = 0;
    unsigned int counter = 0;

    HyperAPI::Shader shader("shaders/default.shader");
    HyperAPI::Shader lightShader("shaders/light.shader");
    HyperAPI::Shader shadowShader("shaders/shadowMap.shader");
    HyperAPI::Shader workerShader("shaders/worker.shader");
    HyperAPI::Shader framebufferShader("shaders/framebuffer.shader");
    HyperAPI::Shader spriteShader("shaders/sprite.shader");
    spriteShader.Bind();
    spriteShader.SetUniform1f("ambient", 0.2);

    HyperAPI::Camera camera(true, width, height, glm::vec3(0.0f, 0, 5.0f));
    // HyperAPI::Entity light(lightVerts, lightInds);

    std::vector<HyperAPI::Texture> textures = {
        HyperAPI::Texture("assets/planks.png", 0, "texture_diffuse"),
        HyperAPI::Texture("assets/planksSpec.png", 1, "texture_specular"),
    };

    HyperAPI::Entity player(spriteVerts2, spriteIndices2, true, true, { HyperAPI::Texture("assets/sprite.png", 0, "texture_diffuse") });
    HyperAPI::Entity bg(bgVerts, bgIndices, false, true, textures);
    
    HyperAPI::Model x_pos_worker("assets/models/workers/Position/x.obj", false, Vector3(0, 0, 1));
    HyperAPI::Model y_pos_worker("assets/models/workers/Position/y.obj", false, Vector3(0.8, 1, 0));
    HyperAPI::Model z_pos_worker("assets/models/workers/Position/z.obj", false, Vector3(1, 0.2, 0));

    for(int i = 0; i < z_pos_worker.meshes.size(); i++) {
        x_pos_worker.meshes[i].model = glm::translate(x_pos_worker.meshes[i].model, glm::vec3(0, 0.5, 0));
        y_pos_worker.meshes[i].model = glm::translate(y_pos_worker.meshes[i].model, glm::vec3(0, 0.5, 0));
        z_pos_worker.meshes[i].model = glm::translate(z_pos_worker.meshes[i].model, glm::vec3(0, 0.5, 0));
    }

    framebufferShader.Bind();
    framebufferShader.SetUniform1i("screenTexture", 0);
    
    glfwSwapInterval(1);

    unsigned int rectVAO, rectVBO;
    glGenVertexArrays(1, &rectVAO);
    glGenBuffers(1, &rectVBO);
    glBindVertexArray(rectVAO);
    glBindBuffer(GL_ARRAY_BUFFER, rectVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(rectangleVert), &rectangleVert, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));

	unsigned int shadowMapFBO;
	glGenFramebuffers(1, &shadowMapFBO);

	// Texture for Shadow Map FBO
	unsigned int shadowMapWidth = 2048, shadowMapHeight = 2048;
	unsigned int shadowMap;
	glGenTextures(1, &shadowMap);
	glBindTexture(GL_TEXTURE_2D, shadowMap);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, shadowMapWidth, shadowMapHeight, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
	// Prevents darkness outside the frustrum
	float clampColor[] = { 1.0f, 1.0f, 1.0f, 1.0f };
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, clampColor);

	glBindFramebuffer(GL_FRAMEBUFFER, shadowMapFBO);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, shadowMap, 0);
	glDrawBuffer(GL_NONE);
	glReadBuffer(GL_NONE);
	glBindFramebuffer(GL_FRAMEBUFFER, 0);

    glm::mat4 orthogonalProjection = glm::ortho(-35.0f, 35.0f, -35.0f, 35.0f, -0.1f, 75.0f);
    glm::mat4 lightView = glm::lookAt(20.0f * Vector3(1, 1, 0), glm::vec3(0, 0, 0), glm::vec3(0, 1, 0));
    glm::mat4 lightProjection = orthogonalProjection * lightView;

    shadowShader.Bind();
    shadowShader.SetUniformMat4("lightProjection", lightProjection);

    HyperAPI::Skybox skybox(
        "assets/skybox/right.jpg",
		"assets/skybox/left.jpg",
		"assets/skybox/top.jpg",
		"assets/skybox/bottom.jpg",
		"assets/skybox/front.jpg",
		"assets/skybox/back.jpg"
    );

    // Physics simulation test
    b2BodyDef groundBodyDef;
    groundBodyDef.position.Set(0.0f, -10.0f);
    b2Body *groundBody = world->CreateBody(&groundBodyDef);
    b2PolygonShape groundBox;
    groundBox.SetAsBox(50.0f, 10.0f);
    groundBody->CreateFixture(&groundBox, 0.0f);

    b2BodyDef bodyDef;
    bodyDef.type = b2_dynamicBody;
    bodyDef.position.Set(0.0f, 5.0f);
    b2Body *body = world->CreateBody(&bodyDef);

    // rotate body on z a little    
    b2Vec2 bodyPos = body->GetPosition();
    body->SetTransform(bodyPos, body->GetAngle() + 15.0f);

    b2PolygonShape dynamicBox;
    dynamicBox.SetAsBox(1.0f, 1.0f);

    b2FixtureDef fixtureDef;
    fixtureDef.shape = &dynamicBox;
    fixtureDef.density = 1.0f;
    fixtureDef.friction = 0.3f;
    fixtureDef.restitution = 0.5f;
    fixtureDef.restitutionThreshold = 0.5f;

    body->CreateFixture(&fixtureDef);

    float timeStep = 1.0f / 60.0f;

    // sphere.meshes[0].model = glm::translate(glm::mat4(1.0f), Vector3(0, 1.5, 0));
    unsigned int FBO;
    glGenFramebuffers(1, &FBO);
    glBindFramebuffer(GL_FRAMEBUFFER, FBO);

    unsigned int bufferTexture;
    glGenTextures(1, &bufferTexture);
    glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, bufferTexture);
    glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, renderer.samples, GL_RGB, width, height, GL_TRUE);
    glTexParameteri(GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, bufferTexture, 0);
    
    unsigned int rbo;
    glGenRenderbuffers(1, &rbo);
    glBindRenderbuffer(GL_RENDERBUFFER, rbo);
    glRenderbufferStorageMultisample(GL_RENDERBUFFER, renderer.samples, GL_DEPTH24_STENCIL8, width, height);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);

    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "ERROR::FRAMEBUFFER:: Framebuffer is not complete!" << std::endl;

    unsigned int postProcessingFBO;
    glGenFramebuffers(1, &postProcessingFBO);
    glBindFramebuffer(GL_FRAMEBUFFER, postProcessingFBO);

    unsigned int postProcessingTexture;
    glGenTextures(1, &postProcessingTexture);
    glBindTexture(GL_TEXTURE_2D, postProcessingTexture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, postProcessingTexture, 0);

    Lights2D.push_back({
        .lightPos = Vector3(0, 0, 0),
        .color = Vector3(1, 1, 1),
        .range = 1
    });

    while(!glfwWindowShouldClose(renderer.window)) {

        if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
            std::cout << "ERROR::FRAMEBUFFER:: Framebuffer is not complete!" << std::endl;

        currTime = glfwGetTime();
        timeDiff = currTime - prevTime;
        counter++;
        if(timeDiff >= 1 / 30) {
            std::string FPS = std::to_string((1 / timeDiff) * counter);
            std::string ms = std::to_string((timeDiff / counter) * 1000);

            std::string newTitle = "FPS: " + FPS + " | MS: " + ms;
            // glfwSetWindowTitle(renderer.window, newTitle.c_str());
            prevTime = currTime;
            counter = 0;
            camera.Inputs(renderer.window);
        }

        glfwPollEvents();

        world->Step(timeStep, 6, 2);
        b2Vec2 position = body->GetPosition();
        b2Vec2 floorPos = groundBody->GetPosition();
        float angle = body->GetAngle();

        camera.updateMatrix(45.0f, 0.1f, 100.0f);

        glViewport(0, 0, width, height);
        NewFrame(FBO);

        TransformComponent component = player.GetComponent<TransformComponent>();
        component.rotation.z += 45;
        player.UpdateComponent(component);

        bg.Draw(spriteShader, camera);
        player.Draw(spriteShader, camera);
    
        glClear(GL_DEPTH_BUFFER_BIT);

        EndFrame(framebufferShader, FBO, rectVAO, postProcessingTexture, postProcessingFBO);
        glfwSwapBuffers(renderer.window);

    }

    return 0;
}